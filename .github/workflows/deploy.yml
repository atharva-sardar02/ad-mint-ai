name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

env:
  AWS_REGION: us-east-1
  S3_FRONTEND_BUCKET: ad-mint-ai-frontend
  EC2_DEPLOYMENT_PATH: /var/www/ad-mint-ai
  EC2_HOST: 44.210.144.149
  API_BASE_URL: http://44.210.144.149

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key.pem
          chmod 600 ~/.ssh/ec2_key.pem
          ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Build frontend
        working-directory: ./frontend
        env:
          VITE_API_URL: ${{ env.API_BASE_URL }}
        run: |
          npm ci
          npm run build

      - name: Deploy frontend to S3
        run: |
          aws s3 sync frontend/dist/ s3://${{ env.S3_FRONTEND_BUCKET }}/ --delete
          echo "‚úÖ Frontend deployed to S3"

      - name: Verify frontend deployment
        run: |
          # Check if index.html exists in S3
          if aws s3 ls s3://${{ env.S3_FRONTEND_BUCKET }}/index.html > /dev/null 2>&1; then
            echo "‚úÖ Frontend deployment verified"
          else
            echo "‚ùå Frontend deployment verification failed"
            exit 1
          fi

      - name: Cleanup old backups and free disk space
        run: |
          ssh -i ~/.ssh/ec2_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USERNAME }}@${{ env.EC2_HOST }} << 'EOF'
            set -e
            DEPLOYMENT_PATH="${{ env.EC2_DEPLOYMENT_PATH }}"
            DEPLOYMENT_DIR=$(dirname "$DEPLOYMENT_PATH")
            
            echo "üßπ Cleaning up old backups and freeing disk space..."
            
            # Remove old backup directories (keep the most recent .backup and .old-*)
            if [ -d "$DEPLOYMENT_DIR" ]; then
              # Find all .old-* directories, keep only the most recent one
              OLD_BACKUPS=$(sudo find "$DEPLOYMENT_DIR" -maxdepth 1 -type d -name "${DEPLOYMENT_PATH##*/}.old-*" -printf '%T@ %p\n' 2>/dev/null | sort -rn || true)
              
              if [ -n "$OLD_BACKUPS" ]; then
                BACKUP_COUNT=$(echo "$OLD_BACKUPS" | wc -l)
                if [ "$BACKUP_COUNT" -gt 1 ]; then
                  echo "üóëÔ∏è  Found $BACKUP_COUNT old .old-* directories, keeping most recent, removing others..."
                  KEEP_FIRST=true
                  echo "$OLD_BACKUPS" | while read -r timestamp dir; do
                    if [ "$KEEP_FIRST" = "true" ]; then
                      echo "  ‚úÖ Keeping most recent: $dir"
                      KEEP_FIRST=false
                    else
                      echo "  üóëÔ∏è  Removing: $dir"
                      sudo rm -rf "$dir" 2>/dev/null || true
                    fi
                  done
                else
                  KEPT_DIR=$(echo "$OLD_BACKUPS" | awk '{print $2}')
                  echo "‚úÖ Keeping only .old-* backup: $KEPT_DIR"
                fi
              fi
              
              # Remove old .backup directory only if we're about to create a new one
              # (We'll create a fresh backup in the next step)
              if [ -d "${DEPLOYMENT_PATH}.backup" ]; then
                echo "üóëÔ∏è  Removing old .backup directory (will create fresh one)..."
                sudo rm -rf "${DEPLOYMENT_PATH}.backup"
              fi
            fi
            
            # Clean up pip cache
            echo "üßπ Cleaning pip cache..."
            pip cache purge 2>/dev/null || true
            sudo -H pip cache purge 2>/dev/null || true
            
            # Clean up apt cache
            echo "üßπ Cleaning apt cache..."
            sudo apt-get clean 2>/dev/null || true
            sudo apt-get autoclean 2>/dev/null || true
            
            # Clean up temporary files
            echo "üßπ Cleaning temporary files..."
            sudo rm -rf /tmp/* 2>/dev/null || true
            sudo rm -rf /var/tmp/* 2>/dev/null || true
            
            # Clean up old journal logs
            echo "üßπ Cleaning old journal logs..."
            sudo journalctl --vacuum-time=7d 2>/dev/null || true
            
            # Show disk usage
            echo "üíæ Current disk usage:"
            df -h / | tail -1
          EOF

      - name: Backup current backend deployment
        run: |
          ssh -i ~/.ssh/ec2_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USERNAME }}@${{ env.EC2_HOST }} << 'EOF'
            set -e
            DEPLOYMENT_PATH="${{ env.EC2_DEPLOYMENT_PATH }}"
            BACKUP_PATH="${DEPLOYMENT_PATH}.backup"
            
            echo "üíæ Creating backup of current deployment..."
            
            # Create backup (with sudo for directory creation, then fix ownership)
            # Use rsync to exclude unnecessary files for faster backup
            if [ -d "$DEPLOYMENT_PATH" ]; then
              echo "üì¶ Copying deployment to backup (excluding large directories)..."
              sudo mkdir -p "$BACKUP_PATH"
              sudo rsync -a --exclude='node_modules' --exclude='venv' --exclude='__pycache__' --exclude='.git' --exclude='*.pyc' --exclude='.pytest_cache' --exclude='dist' --exclude='build' "$DEPLOYMENT_PATH/" "$BACKUP_PATH/"
              sudo chown -R ubuntu:ubuntu "$BACKUP_PATH"
              echo "‚úÖ Backup created at: $BACKUP_PATH"
            else
              echo "‚ö†Ô∏è  Deployment directory not found, skipping backup"
            fi
          EOF

      - name: Deploy backend to EC2
        run: |
          ssh -i ~/.ssh/ec2_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USERNAME }}@${{ env.EC2_HOST }} << 'EOF'
            set -e
            DEPLOYMENT_PATH="${{ env.EC2_DEPLOYMENT_PATH }}"
            
            echo "üöÄ Starting backend deployment..."
            
            # Navigate to deployment directory or create it
            if [ ! -d "$DEPLOYMENT_PATH" ]; then
              echo "üìÅ Creating deployment directory..."
              sudo mkdir -p "$DEPLOYMENT_PATH"
              sudo chown ubuntu:ubuntu "$DEPLOYMENT_PATH"
            fi
            
            cd "$DEPLOYMENT_PATH"
            
            # Check if it's a git repository, if not clone it
            if [ ! -d ".git" ]; then
              echo "üì• Cloning repository (first time deployment or not a git repo)..."
              # Backup .env file if it exists
              ENV_BACKUP="/tmp/ad-mint-ai-env-backup"
              if [ -f "$DEPLOYMENT_PATH/backend/.env" ]; then
                echo "üíæ Backing up .env file..."
                sudo cp "$DEPLOYMENT_PATH/backend/.env" "$ENV_BACKUP" 2>/dev/null || true
              fi
              
              # Remove old deployment directory (but keep venv if it exists to save space)
              if [ -d "$DEPLOYMENT_PATH" ]; then
                echo "üóëÔ∏è  Removing old deployment directory..."
                # Remove everything except venv to save space
                sudo find "$DEPLOYMENT_PATH" -mindepth 1 -maxdepth 1 ! -name "venv" -exec sudo rm -rf {} + 2>/dev/null || true
              fi
              
              # Clone fresh
              git clone https://github.com/atharva-sardar02/ad-mint-ai.git "$DEPLOYMENT_PATH"
              cd "$DEPLOYMENT_PATH"
              sudo chown -R ubuntu:ubuntu "$DEPLOYMENT_PATH"
              
              # Restore .env file if we backed it up
              if [ -f "$ENV_BACKUP" ]; then
                echo "üìù Restoring .env file..."
                sudo cp "$ENV_BACKUP" "$DEPLOYMENT_PATH/backend/.env"
                sudo rm "$ENV_BACKUP"
                sudo chmod 640 "$DEPLOYMENT_PATH/backend/.env"
                sudo chown ubuntu:www-data "$DEPLOYMENT_PATH/backend/.env"
              fi
            else
              # Pull latest code
              echo "üì• Pulling latest code from GitHub..."
              git fetch origin
              git reset --hard origin/main
            fi
            
            # Update dependencies
            echo "üì¶ Updating Python dependencies..."
            cd backend
            
            # Check disk space before creating venv
            AVAILABLE_SPACE=$(df / | tail -1 | awk '{print $4}')
            echo "üíæ Available disk space: ${AVAILABLE_SPACE}KB"
            
            # Remove old venv if disk space is low (less than 500MB)
            if [ "$AVAILABLE_SPACE" -lt 512000 ] && [ -d "venv" ]; then
              echo "‚ö†Ô∏è  Low disk space, removing old venv..."
              rm -rf venv
            fi
            
            # Create venv if it doesn't exist
            if [ ! -d "venv" ]; then
              echo "üêç Creating Python virtual environment..."
              python3 -m venv venv
            fi
            
            source venv/bin/activate
            pip install --upgrade pip --no-cache-dir
            pip install -r requirements.txt --no-cache-dir
            
            # Initialize database (create tables if they don't exist)
            echo "üóÑÔ∏è  Initializing database (creating tables if needed)..."
            python -m app.db.init_db
            if [ $? -ne 0 ]; then
              echo "‚ùå Database initialization failed"
              exit 1
            fi
            echo "‚úÖ Database initialized"
            
            # Run database migrations
            echo "üîÑ Running database migrations..."
            python -m app.db.migrations.run_all
            if [ $? -ne 0 ]; then
              echo "‚ùå Database migrations failed"
              exit 1
            fi
            echo "‚úÖ Database migrations completed"
            
            # Ensure .env file has correct permissions
            if [ -f ".env" ]; then
              echo "üîê Setting .env file permissions..."
              sudo chmod 640 .env
              sudo chown ubuntu:www-data .env
            fi
            
            # Restart FastAPI service
            echo "üîÑ Restarting FastAPI service..."
            sudo systemctl restart fastapi
            
            # Wait for service to start and check status
            echo "‚è≥ Waiting for service to start..."
            sleep 5
            
            # Check service status
            if sudo systemctl is-active --quiet fastapi; then
              echo "‚úÖ FastAPI service is running"
            else
              echo "‚ö†Ô∏è  FastAPI service may not be running, checking logs..."
              sudo journalctl -u fastapi -n 20 --no-pager || true
            fi
            
            echo "‚úÖ Backend deployment completed"
            
            # Show final disk usage
            echo "üíæ Final disk usage:"
            df -h / | tail -1
          EOF

      - name: Health check
        run: |
          echo "üîç Starting health check..."
          MAX_ATTEMPTS=20
          WAIT_SECONDS=5
          API_URL="${{ env.API_BASE_URL }}/api/health"
          
          # First check if service is running on the server
          ssh -i ~/.ssh/ec2_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USERNAME }}@${{ env.EC2_HOST }} << 'SERVICE_CHECK'
            echo "üîç Checking FastAPI service status..."
            if sudo systemctl is-active --quiet fastapi; then
              echo "‚úÖ FastAPI service is active"
              sudo systemctl status fastapi --no-pager -l | head -10
            else
              echo "‚ùå FastAPI service is not active"
              echo "üìã Recent service logs:"
              sudo journalctl -u fastapi -n 30 --no-pager || true
            fi
          SERVICE_CHECK
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "üì° Health check attempt $i/$MAX_ATTEMPTS..."
            
            if response=$(curl -s -f "$API_URL" 2>/dev/null); then
              if echo "$response" | grep -q '"status"[[:space:]]*:[[:space:]]*"healthy"'; then
                echo "‚úÖ Health check passed!"
                echo "Response: $response"
                exit 0
              else
                echo "‚ö†Ô∏è  Service responding but not healthy yet"
                echo "Response: $response"
              fi
            else
              echo "‚è≥ Service not responding yet (attempt $i/$MAX_ATTEMPTS)"
            fi
            
            if [ $i -lt $MAX_ATTEMPTS ]; then
              sleep $WAIT_SECONDS
            fi
          done
          
          echo "‚ùå Health check failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Deployment failed, initiating rollback..."
          ssh -i ~/.ssh/ec2_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USERNAME }}@${{ env.EC2_HOST }} << 'EOF'
            set -e
            DEPLOYMENT_PATH="${{ env.EC2_DEPLOYMENT_PATH }}"
            BACKUP_PATH="${DEPLOYMENT_PATH}.backup"
            
            echo "üîÑ Starting rollback process..."
            
            # Check if backup exists
            if [ ! -d "$BACKUP_PATH" ]; then
              echo "‚ùå Backup directory not found: $BACKUP_PATH"
              echo "‚ö†Ô∏è  Cannot perform rollback"
              exit 1
            fi
            
            echo "‚úÖ Backup found, proceeding with rollback..."
            
            # Stop FastAPI service
            echo "üõë Stopping FastAPI service..."
            sudo systemctl stop fastapi || echo "‚ö†Ô∏è  Service may already be stopped"
            
            # Remove current deployment (preserve .env file)
            ENV_BACKUP="/tmp/ad-mint-ai-env-backup"
            if [ -d "$DEPLOYMENT_PATH" ]; then
              echo "üóëÔ∏è  Removing current deployment..."
              # Backup .env if it exists (to temp location before removing directory)
              if [ -f "$DEPLOYMENT_PATH/backend/.env" ]; then
                echo "üíæ Backing up current .env file..."
                sudo cp "$DEPLOYMENT_PATH/backend/.env" "$ENV_BACKUP"
              fi
              
              # Remove deployment directory
              sudo rm -rf "$DEPLOYMENT_PATH"
            fi
            
            # Restore from backup
            echo "üì¶ Restoring from backup..."
            sudo rsync -a "$BACKUP_PATH/" "$DEPLOYMENT_PATH/"
            
            # Restore .env file if we backed it up (from temp location)
            if [ -f "$ENV_BACKUP" ]; then
              echo "üìù Restoring .env file..."
              sudo cp "$ENV_BACKUP" "$DEPLOYMENT_PATH/backend/.env"
              sudo rm "$ENV_BACKUP"
              sudo chmod 600 "$DEPLOYMENT_PATH/backend/.env"
            fi
            
            # Ensure proper permissions
            echo "üîê Setting permissions..."
            sudo chown -R ubuntu:ubuntu "$DEPLOYMENT_PATH"
            
            # Recreate virtual environment if it doesn't exist (since we excluded it from backup)
            if [ ! -d "$DEPLOYMENT_PATH/backend/venv" ]; then
              echo "üêç Recreating Python virtual environment..."
              cd "$DEPLOYMENT_PATH/backend"
              
              # Ensure backend directory exists and has correct permissions
              if [ ! -d "$DEPLOYMENT_PATH/backend" ]; then
                echo "‚ùå Backend directory not found: $DEPLOYMENT_PATH/backend"
                exit 1
              fi
              
              python3 -m venv venv
              source venv/bin/activate
              pip install --upgrade pip --no-cache-dir
              pip install -r requirements.txt --no-cache-dir
              deactivate
            else
              echo "‚úÖ Virtual environment already exists, skipping recreation"
            fi
            
            # Restart FastAPI service
            echo "üöÄ Restarting FastAPI service..."
            sudo systemctl start fastapi
            
            # Wait a moment for service to start
            sleep 5
            
            # Check service status
            if sudo systemctl is-active --quiet fastapi; then
              echo "‚úÖ FastAPI service is running"
            else
              echo "‚ö†Ô∏è  FastAPI service may not be running properly"
            fi
            
            echo "‚úÖ Rollback completed successfully"
            
            # Clean up old backup directories after successful rollback
            echo "üßπ Cleaning up old backup directories..."
            DEPLOYMENT_DIR=$(dirname "$DEPLOYMENT_PATH")
            if [ -d "$DEPLOYMENT_DIR" ]; then
              # Remove old .old-* directories
              sudo find "$DEPLOYMENT_DIR" -maxdepth 1 -type d -name "${DEPLOYMENT_PATH##*/}.old-*" -exec sudo rm -rf {} + 2>/dev/null || true
            fi
            
            # Show disk usage after cleanup
            echo "üíæ Disk usage after cleanup:"
            df -h / | tail -1
          EOF

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/ec2_key.pem

      - name: Deployment summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
            echo "üåê Frontend: http://${{ env.S3_FRONTEND_BUCKET }}.s3-website-${{ env.AWS_REGION }}.amazonaws.com"
            echo "üîó Backend API: ${{ env.API_BASE_URL }}/api/"
            echo "‚ù§Ô∏è  Health Check: ${{ env.API_BASE_URL }}/api/health"
          else
            echo "‚ùå Deployment failed"
            echo "üîÑ Rollback was attempted if backup was available"
          fi
